using System.Collections.Generic;
using UnityEngine;

namespace Tunnel
{
    /// <summary>
    /// ?°ë„ ??êµ¬ê°„. ?´ì¤‘ LineRenderer(?¸ê³½??+ ì±„ì?) + EdgeCollider2D.
    /// ?¬ì¸??ì¶”ê? ???‘ì˜†?????©ì–´ë¦??Œí‹°?´ì„ ?©ë¿Œ???ì—°?¤ëŸ¬???Œë‘ë¦¬ë? ë§Œë“ ??
    /// </summary>
    [RequireComponent(typeof(LineRenderer))]
    public class TunnelSegment_Legacy : MonoBehaviour
    {
        // ?€?€ ê³µìœ  ë¦¬ì†Œ??(static ìºì‹œë¡?GC/GPU ë¶€??ê°ì†Œ) ?€?€
        private static Texture2D s_circleTexture;
        private static Texture2D s_shadowTexture; // ?¸ë¡œ ê·¸ë¼?°ì´???ìŠ¤ì²?
        private static Shader s_spriteShader;

        private LineRenderer _lr;         // ì±„ì? (??
        private LineRenderer _shadowLr;   // ê·¸ë¦¼??(ì¤‘ê°„)
        private LineRenderer _outlineLr;  // ?¸ê³½??(??
        private EdgeCollider2D _collider;
        private readonly List<Vector3> _points = new List<Vector3>(200);
        private readonly List<Vector2> _colliderPoints = new List<Vector2>(200);

        private int _dirtyCount;
        private const int COLLIDER_SYNC_INTERVAL = 5;

        // ?°ë¸Œë¦??Œí‹°??
        private ParticleSystem _debrisPS;
        private float _tunnelWidth;
        private Color _debrisColor;

        // GC ê°ì†Œ: collider points ë°°ì—´ ìºì‹œ
        private Vector2[] _colliderArray;

        public int PointCount => _points.Count;

        /// <summary>ì²?ë²ˆì§¸ ?¬ì¸??ê¼¬ë¦¬ ?? ?„ì¹˜ ë°˜í™˜. ???œë¡­ ??</summary>
        public Vector3 GetFirstPointPosition()
        {
            return _points.Count > 0 ? _points[0] : Vector3.zero;
        }

        private bool _isInitialized;

        public void Initialize(Material material, Color fillColor, Color outlineColor, float width)
        {
            _tunnelWidth = width;
            _debrisColor = outlineColor;

            // ?´ë? ì´ˆê¸°?”ëœ ê²½ìš°(?€ë§??¬ì‚¬??, ?¤ì •ë§??…ë°?´íŠ¸?˜ê³  ë¦¬í„´
            if (_isInitialized)
            {
                UpdateVisuals(material, fillColor, outlineColor, width);
                Reset(); // ?íƒœ ì´ˆê¸°??
                return;
            }

            EnsureSharedResources();

            // --- ?¸ê³½??LineRenderer (?¤ìª½, ???“ìŒ, ?¨ìƒ‰) ---
            var outlineObj = new GameObject("Outline");
            outlineObj.transform.SetParent(transform, false);
            _outlineLr = outlineObj.AddComponent<LineRenderer>();
            // 1.3ë°?-> 1.2ë°°ë¡œ ??ì¤„ì„ (?Œë‘ë¦??ê»˜ ìµœì†Œ??
            SetupLineRenderer(_outlineLr, outlineColor,
                width * 1.2f, sortingOrder: -2, corners: 8, caps: 4);

            // --- ê·¸ë¦¼??LineRenderer (ì¤‘ê°„, ê·¸ë¼?°ì´?? ---
            var shadowObj = new GameObject("Shadow");
            shadowObj.transform.SetParent(transform, false);
            _shadowLr = shadowObj.AddComponent<LineRenderer>();
            
            // ê·¸ë¦¼???¬ì§ˆ (?°ìƒ‰ ê·¸ë¼?°ì´???ìŠ¤ì²?+ ê²€???´íŠ¸)
            var shadowMat = new Material(s_spriteShader);
            shadowMat.mainTexture = s_shadowTexture;
            _shadowLr.material = shadowMat;
            
            // ê²€?•ìƒ‰ (?ŒíŒŒê°’ìœ¼ë¡?ì§„í•˜ê¸?ì¡°ì ˆ)
            Color shadowColor = new Color(0f, 0f, 0f, 0.6f); 
            SetupLineRenderer(_shadowLr, shadowColor,
                width, sortingOrder: -1, corners: 8, caps: 4, isShadow: true);

            // --- ì±„ì? LineRenderer (?ìª½, ê¸°ë³¸ ?‰ìƒ) ---
            _lr = GetComponent<LineRenderer>();
            SetupLineRenderer(_lr, fillColor,
                width, sortingOrder: -1, corners: 8, caps: 4); 
            _shadowLr.sortingOrder = 0; 
            _lr.sortingOrder = -1;

            // --- ì½œë¼?´ë” ---
            _collider = gameObject.AddComponent<EdgeCollider2D>();
            _collider.edgeRadius = width * 0.5f;
            _collider.isTrigger = true;
            _collider.enabled = false;

            // --- ?°ë¸Œë¦??Œí‹°??---
            CreateDebrisParticleSystem(outlineColor);

            _isInitialized = true;
        }

        /// <summary>?€ë§??¬ì‚¬?©ì„ ?„í•œ ?íƒœ ì´ˆê¸°??/summary>
        public void Reset()
        {
            _points.Clear();
            _colliderPoints.Clear();
            
            if (_lr != null) _lr.positionCount = 0;
            if (_outlineLr != null) _outlineLr.positionCount = 0;
            if (_shadowLr != null) _shadowLr.positionCount = 0;

            if (_collider != null)
            {
                _collider.enabled = false;
                _collider.points = System.Array.Empty<Vector2>();
            }

            _dirtyCount = 0;
            // ?œì„±??
            gameObject.SetActive(true);
        }

        private void UpdateVisuals(Material material, Color fillColor, Color outlineColor, float width)
        {
            if (_lr != null)
            {
                _lr.startColor = fillColor;
                _lr.endColor = fillColor;
                _lr.startWidth = width;
                _lr.endWidth = width;
                // Material?€ ê³µìœ ?˜ë?ë¡??¸ìŠ¤?´ìŠ¤??ì£¼ì˜ (?¬ê¸°?œëŠ” ? ì?)
            }

            if (_outlineLr != null)
            {
                _outlineLr.startColor = outlineColor;
                _outlineLr.endColor = outlineColor;
                // 1.3 -> 1.2
                _outlineLr.startWidth = width * 1.2f;
                _outlineLr.endWidth = width * 1.2f;
            }
            
            if (_shadowLr != null)
            {
                _shadowLr.startWidth = width;
                _shadowLr.endWidth = width;
            }

            if (_debrisPS != null)
            {
                var main = _debrisPS.main;
                main.startColor = new ParticleSystem.MinMaxGradient(
                    outlineColor,
                    outlineColor * 1.3f
                );
            }
        }

        // ?˜ìœ„?¸í™˜: ?´ì „ ?œê·¸?ˆì²˜ ì§€??
        public void Initialize(Material material, Color color, float width)
        {
            Color outline = color * 0.5f;
            outline.a = 1f;
            Initialize(material, color, outline, width);
        }

        // ?€?€ ?•ì  ë¦¬ì†Œ??ì´ˆê¸°??(??ë²ˆë§Œ ?¤í–‰) ?€?€
        private static void EnsureSharedResources()
        {
            if (s_spriteShader == null)
            {
                s_spriteShader = Shader.Find("Sprites/Default");
                if (s_spriteShader == null)
                    s_spriteShader = Shader.Find("Universal Render Pipeline/2D/Sprite-Unlit-Default");
            }

            if (s_circleTexture == null)
                s_circleTexture = CreateCircleTexture(32);

            if (s_shadowTexture == null)
                s_shadowTexture = CreateShadowTexture(64, 32);
        }

        // ?€?€ ?°ë¸Œë¦??Œí‹°???œìŠ¤???€?€
        private void CreateDebrisParticleSystem(Color color)
        {
            var psObj = new GameObject("Debris");
            psObj.transform.SetParent(transform, false);

            _debrisPS = psObj.AddComponent<ParticleSystem>();

            // ?˜ë™ Emitë§??¬ìš© (?ë™ ë°©ì¶œ ?†ìŒ)
            var main = _debrisPS.main;
            main.startLifetime = 999f;
            main.startSpeed = 0f;
            main.startSize = new ParticleSystem.MinMaxCurve(
                _tunnelWidth * 0.15f, _tunnelWidth * 0.4f);
            main.startColor = new ParticleSystem.MinMaxGradient(
                color,
                color * 1.3f
            );
            main.startRotation = new ParticleSystem.MinMaxCurve(0f, 360f * Mathf.Deg2Rad);
            main.simulationSpace = ParticleSystemSimulationSpace.World;
            main.maxParticles = 800;
            main.playOnAwake = false;

            var emission = _debrisPS.emission;
            emission.rateOverTime = 0f;

            var shape = _debrisPS.shape;
            shape.enabled = false;

            // Renderer: ê³µìœ  ?í˜• ?ìŠ¤ì²??¬ìš©
            var renderer = psObj.GetComponent<ParticleSystemRenderer>();
            var circleMat = new Material(s_spriteShader);
            circleMat.mainTexture = s_circleTexture;
            renderer.material = circleMat;
            renderer.sortingOrder = 0;
            renderer.renderMode = ParticleSystemRenderMode.Billboard;

            _debrisPS.Stop();
        }

        /// <summary>?°ë„ ê°€?¥ìë¦¬ì— ???©ì–´ë¦??Œí‹°?´ì„ ?©ë¿Œë¦°ë‹¤.</summary>
        private void EmitDebris(Vector3 pos, Vector3 direction)
        {
            if (_debrisPS == null) return;

            Vector3 perpendicular = new Vector3(-direction.y, direction.x, 0f).normalized;
            // ?¸ê³½??ë°˜ê²½: width * 0.6 (1.2f / 2)
            // ?Œí‹°???ì„± ?„ì¹˜: ?¸ê³½??ê²½ê³„??ê±¸ì¹˜?„ë¡ ??
            // 0.55f ~ 0.65f (?‰ê·  0.6f) -> ?Œí‹°?´ì˜ ì¤‘ì‹¬???„ì›ƒ?¼ì¸ ?„ì— ??
            float baseOffset = _tunnelWidth * 0.55f; 

            int count = Random.Range(2, 4);
            var emitParams = new ParticleSystem.EmitParams();

            for (int i = 0; i < count; i++)
            {
                float side = (i % 2 == 0) ? 1f : -1f;
                // ?½ê°„???œë¤ (0.55 ~ 0.65)
                float offset = baseOffset + _tunnelWidth * Random.Range(0.0f, 0.1f);

                emitParams.position = pos + perpendicular * (side * offset);
                emitParams.velocity = Vector3.zero;
                // ?¬ê¸°: 0.2 ~ 0.4 (?°ë„ ë²½ê³¼ ?ì—°?¤ëŸ½ê²?ê²¹ì¹˜ê²?
                emitParams.startSize = _tunnelWidth * Random.Range(0.2f, 0.4f);
                emitParams.startLifetime = 999f;

                // ?‰ìƒ ë¯¸ì„¸ ë³€??
                Color c = _debrisColor;
                float v = Random.Range(-0.08f, 0.08f);
                c.r = Mathf.Clamp01(c.r + v);
                c.g = Mathf.Clamp01(c.g + v);
                c.b = Mathf.Clamp01(c.b + v);
                emitParams.startColor = c;

                _debrisPS.Emit(emitParams, 1);
            }
        }

        // ?€?€ LineRenderer ?¤ì • ?€?€
        private void SetupLineRenderer(LineRenderer lr,
            Color color, float width, int sortingOrder, int corners, int caps, bool isShadow = false)
        {
            if (!isShadow)
            {
                var instanceMat = new Material(s_spriteShader);
                lr.material = instanceMat;
            }
            // Shadow??Initialize?ì„œ ë³„ë„ Material ? ë‹¹??

            lr.startColor = color;
            lr.endColor = color;
            lr.startWidth = width;
            lr.endWidth = width;
            lr.numCornerVertices = corners;
            lr.numCapVertices = caps;
            lr.useWorldSpace = true;
            lr.sortingOrder = sortingOrder;
            lr.positionCount = 0;
            
            // ?ìŠ¤ì²?ëª¨ë“œ: Stretch (ê·¸ë¼?°ì´?˜ì´ ?¼ì¸ ?„ì²´ ê¸¸ì´ê°€ ?„ë‹ˆ???ˆë¹„ ë°©í–¥?¼ë¡œ ?ìš©?˜ê²Œ ?˜ë ¤ë©?Tile ëª¨ë“œ ?±ì„ ê³ ë ¤?´ì•¼ ?˜ì?ë§?
            // LineRenderer ê¸°ë³¸ ë§¤í•‘?€ U:ê¸¸ì´, V:?ˆë¹„ ?´ë?ë¡?Stretchê°€ ?ì ˆ??
            lr.textureMode = LineTextureMode.Stretch; 

            // ê¼¬ë¦¬?’ë¨¸ë¦??ì—°?¤ëŸ¬???ˆë¹„ ë³€??
            lr.widthCurve = new AnimationCurve(
                new Keyframe(0.0f, 0.3f),
                new Keyframe(0.1f, 0.8f),
                new Keyframe(0.3f, 1.0f),
                new Keyframe(0.9f, 1.0f),
                new Keyframe(1.0f, 0.7f)
            );
        }

        // ?€?€ ?¬ì¸??ê´€ë¦??€?€
        public void AddPoint(Vector3 worldPos)
        {
            _points.Add(worldPos);

            int count = _points.Count;
            _lr.positionCount = count + 1;
            _lr.SetPosition(count - 1, worldPos);
            _lr.SetPosition(count, worldPos);

            _outlineLr.positionCount = count + 1;
            _outlineLr.SetPosition(count - 1, worldPos);
            _outlineLr.SetPosition(count, worldPos);
            
            _shadowLr.positionCount = count + 1;
            _shadowLr.SetPosition(count - 1, worldPos);
            _shadowLr.SetPosition(count, worldPos);

            // ?°ë¸Œë¦??©ë¿Œë¦¬ê¸° (ë°©í–¥???ˆì„ ?Œë§Œ)
            if (count >= 2)
            {
                Vector3 dir = (_points[count - 1] - _points[count - 2]).normalized;
                EmitDebris(worldPos, dir);
            }

            _colliderPoints.Add(worldPos);
            _dirtyCount++;

            if (_dirtyCount >= COLLIDER_SYNC_INTERVAL)
            {
                SyncCollider();
                _dirtyCount = 0;
            }
        }

        /// <summary>ë§??„ë ˆ???¸ì¶œ. LineRenderer ë§??ì„ ?Œë ˆ?´ì–´ ?„ì¹˜??ê³ ì •.</summary>
        public void UpdateLiveHead(Vector3 playerPos)
        {
            if (_lr.positionCount > 0)
            {
                _lr.SetPosition(_lr.positionCount - 1, playerPos);
                _outlineLr.SetPosition(_outlineLr.positionCount - 1, playerPos);
                _shadowLr.SetPosition(_shadowLr.positionCount - 1, playerPos);
            }
        }

        public void SlideTailPoint(float t)
        {
            if (_points.Count < 2) return;

            Vector3 lerped = Vector3.Lerp(_points[0], _points[1], t);
            _lr.SetPosition(0, lerped);
            _outlineLr.SetPosition(0, lerped);
            _shadowLr.SetPosition(0, lerped);

            if (_colliderPoints.Count >= 2 && _collider.enabled)
            {
                _colliderPoints[0] = lerped;
                SyncCollider();
            }
        }

        public void RemoveFirstPoint()
        {
            if (_points.Count < 2) return;

            _points.RemoveAt(0);

            int count = _points.Count;
            _lr.positionCount = count + 1;
            _outlineLr.positionCount = count + 1;
            _shadowLr.positionCount = count + 1;

            for (int i = 0; i < count; i++)
            {
                _lr.SetPosition(i, _points[i]);
                _outlineLr.SetPosition(i, _points[i]);
                _shadowLr.SetPosition(i, _points[i]);
            }

            _lr.SetPosition(count, _points[count - 1]);
            _outlineLr.SetPosition(count, _points[count - 1]);
            _shadowLr.SetPosition(count, _points[count - 1]);

            if (_colliderPoints.Count > 0)
                _colliderPoints.RemoveAt(0);

            if (_collider.enabled)
                SyncCollider();
        }

        // ?€?€ Collider ?™ê¸°??(GC ê°ì†Œ: ë°°ì—´ ìºì‹œ) ?€?€
        private void SyncCollider()
        {
            int count = _colliderPoints.Count;
            if (count < 2) return;

            if (_colliderArray == null || _colliderArray.Length != count)
                _colliderArray = new Vector2[count];

            for (int i = 0; i < count; i++)
                _colliderArray[i] = _colliderPoints[i];

            _collider.points = _colliderArray;
        }

        public void FlushCollider() => SyncCollider();

        public void EnableCollider()
        {
            FlushCollider();
            if (_collider != null)
                _collider.enabled = true;
        }

        public void SetWidth(float width)
        {
            _tunnelWidth = width;
            if (_lr != null)
            {
                _lr.startWidth = width;
                _lr.endWidth = width;
            }
            if (_outlineLr != null)
            {
                _outlineLr.startWidth = width * 1.5f;
                _outlineLr.endWidth = width * 1.5f;
            }
            if (_shadowLr != null)
            {
                _shadowLr.startWidth = width;
                _shadowLr.endWidth = width;
            }
            if (_collider != null)
                _collider.edgeRadius = width * 0.5f;
        }

        // ?€?€ ? í‹¸ë¦¬í‹° ?€?€

        /// <summary>?°í??„ì— ?í˜• ?ìŠ¤ì²˜ë? ?ì„±?œë‹¤ (static ìºì‹œ).</summary>
        private static Texture2D CreateCircleTexture(int size)
        {
            var tex = new Texture2D(size, size, TextureFormat.RGBA32, false);
            float center = size * 0.5f;
            float radius = center - 1f;

            for (int y = 0; y < size; y++)
            {
                for (int x = 0; x < size; x++)
                {
                    float dx = x - center + 0.5f;
                    float dy = y - center + 0.5f;
                    float dist = Mathf.Sqrt(dx * dx + dy * dy);
                    float alpha = Mathf.Clamp01(radius - dist + 0.5f);
                    tex.SetPixel(x, y, new Color(1f, 1f, 1f, alpha));
                }
            }

            tex.Apply();
            tex.filterMode = FilterMode.Bilinear;
            return tex;
        }

        /// <summary>
        /// ?¸ë¡œ ê·¸ë¼?°ì´???ìŠ¤ì²??ì„± (Top: Opaque, Center: Transparent, Bottom: Opaque)
        /// Vì¢Œí‘œê°€ ?ˆë¹„ ë°©í–¥ (0~1). 1???„ìª½(Top Edge), 0???„ë˜ìª?Bottom Edge).
        /// LineRenderer TextureMode.Stretch ê¸°ì?.
        /// </summary>
        private static Texture2D CreateShadowTexture(int width, int height)
        {
            var tex = new Texture2D(width, height, TextureFormat.RGBA32, false);
            
            for (int y = 0; y < height; y++)
            {
                // V: 0 (Below) -> 1 (Above)
                float v = (float)y / (height - 1);
                
                // ê·¸ë¦¼??ë¡œì§: ?‘ìª½ ??0.0, 1.0)?€ ì§„í•˜ê³? ì¤‘ì•™(0.5)?€ ?¬ëª…
                // Pipe ?•íƒœ???…ì²´ê°??œí˜„
                
                // ì¤‘ì‹¬(0.5)?ì„œ ?¼ë§ˆ???¨ì–´???ˆëŠ”ì§€ (0 ~ 0.5)
                float dist = Mathf.Abs(v - 0.5f);
                
                // 0.3 ?´ìƒ(ê°€?¥ìë¦?20%)ë¶€??ê·¸ë¦¼???œì‘
                // 0.3 -> 0.0, 0.5 -> 1.0
                float alpha = 0f;
                if (dist > 0.3f)
                {
                    alpha = (dist - 0.3f) / 0.2f;
                    // ë¶€?œëŸ¬??ê³¡ì„  (Ease-In)
                    alpha = alpha * alpha; 
                }

                Color c = new Color(1f, 1f, 1f, alpha); // RGB???°ìƒ‰(Tintë¡?ê²€??ë§Œë“¦), Aê°€ ê·¸ë¦¼??ê°•ë„
                
                for (int x = 0; x < width; x++)
                {
                    tex.SetPixel(x, y, c);
                }
            }

            tex.Apply();
            tex.wrapMode = TextureWrapMode.Clamp;
            tex.filterMode = FilterMode.Bilinear;
            return tex;
        }
    }
}
